# https://school.programmers.co.kr/learn/courses/30/lessons/77886

def solution(s):
    """
    ref: https://www.ai-bio.info/programmers/77886

    1. ("110" 찾기 -> 삽입하기) 를 반복하지 않아도 된다. (모든 "110" 찾기 -> 한꺼번에 삽입하기) 도 가능하다.
        이것이 가능한 이유는 "110"을 삽입할 때, 다시 "110"이 생기지 않기 때문이다. 모든 경우의 수를 따져보면 다음과 같다.
            0 110 0
            0 110 1
            1 110 0
            1 110 1
        이처럼 "110" 양쪽에 각각 (0, 0), (0, 1), (1, 0), (1, 1)이 오더라도 새롭게 "110"이 생기지 않는다.

    2. 1번을 위해서 stack을 이용해 "110"가 발견될 때마다 제거하고, 모든 "110"의 개수를 세어준다.

    3. 모든 "110"을 넣음으로써 사전 순으로 가장 앞에 오는 문자열을 만들어야 하므로, 가장 오른쪽에 위치한 0 다음에 모든 "110"을 붙여준다.
        - "110" 보다 사전 순으로 큰 것은 "111" 밖에 없다. 따라서 "111"이 있던 위치에 "110"을 끼워넣어야 사전 순으로 앞에 갈 수 있다.
        - 가장 오른쪽에 위치한 0 다음에 "110"을 붙여주어야 하는 이유는, 해당 0의 왼쪽에는 "111"이 올 수 없기 때문이다.
          "111"이 만약 해당 0의 왼쪽에 존재한다면 "110"이 필연적으로 발생하게 되는데, 이전에 우리는 모든 "110"을 제거했기 때문에 이는 불가능하다.
        - 0이 없는 경우라면, 모든 "110"을 가장 왼쪽에 붙여주면 된다.
    """

    answer = []

    def solve(nums):
        # 모든 "110" 찾기
        stack = []
        cnt = 0
        for n in nums:
            stack.append(n)
            while len(stack) >= 3 and stack[-3:] == ["1", "1", "0"]:
                del stack[-3:]
                cnt += 1

        # "110"이 없다면 그대로 반환
        if not cnt:
            return nums

        # 가장 오른쪽에 위치한 0을 찾으면, 그 오른쪽에 "110" * cnt 끼워넣기
        for i in range(len(stack) - 1, -1, -1):
            if stack[i] == "0":
                return "".join(stack[:i + 1]) + "110" * cnt + "".join(stack[i + 1:])

        # 0이 없다면 가장 왼쪽에 "110" * cnt 넣기
        return "110" * cnt + "".join(stack)

    for nums in s:
        answer.append(solve(nums))

    return answer
